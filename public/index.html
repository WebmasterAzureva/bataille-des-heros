<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Bataille des H√©ros</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }
        
        .lobby { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; }
        .lobby.hidden { display: none; }
        .lobby-title { font-size: 3em; color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,0.5); margin-bottom: 30px; }
        .lobby-box { background: rgba(20,20,40,0.95); padding: 35px; border-radius: 15px; border: 3px solid #8b7355; text-align: center; min-width: 380px; }
        .lobby-btn { display: block; width: 100%; padding: 16px; margin: 12px 0; font-size: 1.1em; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s; font-family: 'Cinzel', serif; }
        .lobby-btn:hover { transform: scale(1.05); }
        .btn-create { background: linear-gradient(135deg, #8b4513, #cd853f); color: white; }
        .btn-join { background: linear-gradient(135deg, #2e4a2e, #4a7c4a); color: white; }
        .room-code-input { width: 100%; padding: 14px; font-size: 1.6em; text-align: center; border: 3px solid #8b7355; border-radius: 8px; background: rgba(0,0,0,0.5); color: #ffd700; margin: 12px 0; text-transform: uppercase; letter-spacing: 8px; }
        .room-code-display { font-size: 2.5em; color: #ffd700; letter-spacing: 10px; margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; }
        .waiting-text { color: #aaa; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .game-container { width: 100vw; height: 100vh; display: none; position: relative; }
        .game-container.active { display: block; }
        
        .top-bar { position: absolute; top: 0; left: 0; right: 0; height: 50px; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; background: rgba(20,20,40,0.95); border-bottom: 2px solid #5a4a3a; z-index: 50; }
        .player-info-bar { display: flex; align-items: center; gap: 12px; }
        .rank-badge { background: #5a5a7a; padding: 4px 12px; border-radius: 4px; font-size: 0.75em; }
        .player-name { font-size: 0.9em; padding: 6px 15px; border-radius: 5px; }
        .player-name.me { background: linear-gradient(135deg, #2a4a6a, #1a3a5a); border: 2px solid #4a7c9a; }
        .player-name.opp { background: linear-gradient(135deg, #6a2a4a, #5a1a3a); border: 2px solid #9a4a7c; }
        .options-btn { width: 35px; height: 35px; border-radius: 50%; background: #5a4a3a; border: 2px solid #8b7355; cursor: pointer; font-size: 1em; }
        
        .header-center { position: absolute; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 15px; }
        .header-timer { font-size: 1.8em; font-weight: bold; color: #e74c3c; text-shadow: 0 0 15px rgba(231,76,60,0.8); min-width: 50px; text-align: center; display: none; }
        .header-timer.visible { display: block; }
        .header-timer.urgent { animation: timerPulse 0.5s infinite; }
        @keyframes timerPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); color: #ff4444; } }
        
        .energy-display { display: flex; align-items: center; gap: 8px; }
        .mana-orb { width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #7ec8f3, #1e90ff, #0066cc); border: 3px solid #87ceeb; box-shadow: 0 0 15px rgba(30,144,255,0.6); display: flex; align-items: center; justify-content: center; font-size: 1.1em; font-weight: bold; }
        .energy-text { font-size: 1.2em; color: #87ceeb; font-weight: bold; }
        
        .end-turn-btn { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); width: 90px; height: 90px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #ff6b35, #c41e00); border: 4px solid #ffd700; cursor: pointer; font-size: 0.65em; font-weight: bold; color: white; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        .end-turn-btn:hover:not(.waiting) { transform: translateX(-50%) scale(1.08); box-shadow: 0 6px 25px rgba(255,107,53,0.5); }
        .end-turn-btn.waiting { background: radial-gradient(circle at 30% 30%, #666, #444); border-color: #888; cursor: default; }
        
        .phase-indicator { position: absolute; top: 155px; left: 50%; transform: translateX(-50%); padding: 8px 25px; background: rgba(46,204,113,0.9); border-radius: 20px; border: 2px solid #58d68d; font-size: 0.8em; z-index: 90; white-space: nowrap; opacity: 1; transition: opacity 0.5s ease-out; }
        .phase-indicator.fade-out { opacity: 0; }
        .phase-indicator.redeploy { background: rgba(52,152,219,0.9); border-color: #5dade2; }
        .phase-indicator.deploy { background: rgba(46,204,113,0.9); border-color: #58d68d; }
        .phase-indicator.resolution { background: rgba(231,76,60,0.9); border-color: #ec7063; }
        
        .side-panel { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .side-panel.left { left: 15px; }
        .side-panel.right { right: 15px; }
        
        .hero-card { width: 110px; height: 150px; border-radius: 10px; background: linear-gradient(135deg, #3a3a5a, #2a2a4a); border: 4px solid #5a5a8a; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; box-shadow: 0 5px 20px rgba(0,0,0,0.5); transition: all 0.3s; }
        .side-panel.left .hero-card { border-color: #4a9a4a; background: linear-gradient(135deg, #2a4a3a, #1a3a2a); }
        .side-panel.right .hero-card { border-color: #9a4a4a; background: linear-gradient(135deg, #4a2a3a, #3a1a2a); }
        .hero-card.hit { animation: heroHit 0.5s ease-out; }
        @keyframes heroHit { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(255,0,0,0.8); } }
        .hero-label { font-size: 0.7em; margin-bottom: 5px; color: #ffd700; font-weight: bold; }
        .hero-icon { font-size: 3em; }
        .hero-hp { position: absolute; bottom: -15px; left: 50%; transform: translateX(-50%); background: radial-gradient(circle at 30% 30%, #e74c3c, #922b21); width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.3em; font-weight: bold; border: 3px solid #f5b7b1; box-shadow: 0 3px 10px rgba(0,0,0,0.4); transition: all 0.3s; }
        .ready-dot { position: absolute; top: -8px; right: -8px; width: 22px; height: 22px; border-radius: 50%; background: #7f8c8d; border: 3px solid white; font-size: 0.5em; display: flex; align-items: center; justify-content: center; }
        .ready-dot.ready { background: #27ae60; }
        
        .deck-grave-row { display: flex; gap: 8px; margin-top: 15px; }
        .deck-box, .grave-box { width: 90px; height: 120px; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.7em; }
        .deck-box { background: linear-gradient(135deg, #4a3a2a, #2a2015); border: 3px solid #8b7355; }
        .grave-box { background: linear-gradient(135deg, #3a3a4a, #2a2a3a); border: 3px dashed #6a6a7a; }
        .deck-icon { font-size: 2em; margin-bottom: 5px; }
        .deck-count { font-size: 1.2em; font-weight: bold; }
        
        .battlefield { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; gap: 10px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 12px; border: 2px solid rgba(139,115,85,0.3); }
        
        .field-side { display: grid; grid-template-columns: repeat(2, 90px); grid-template-rows: repeat(4, 120px); gap: 5px; }
        
        .trap-center { display: flex; gap: 6px; }
        .trap-col { display: grid; grid-template-rows: repeat(4, 120px); gap: 5px; }
        
        .card-slot { width: 90px; height: 120px; border: 2px dashed rgba(139,155,200,0.4); border-radius: 6px; background: rgba(139,155,200,0.08); cursor: pointer; transition: all 0.2s; position: relative; display: flex; align-items: center; justify-content: center; }
        .card-slot .slot-label { position: absolute; font-size: 0.65em; color: rgba(255,255,255,0.25); pointer-events: none; }
        .card-slot:hover { border-color: rgba(255,215,0,0.5); background: rgba(255,215,0,0.1); }
        .card-slot.me-slot { border-color: rgba(74,124,150,0.4); background: rgba(74,124,150,0.08); }
        .card-slot.opp-slot { border-color: rgba(150,74,100,0.4); background: rgba(150,74,100,0.08); }
        .card-slot.has-card { border-color: transparent; background: transparent; }
        .card-slot.valid-target { border-color: #2ecc71 !important; background: rgba(46,204,113,0.25) !important; box-shadow: 0 0 15px rgba(46,204,113,0.5); animation: validPulse 1s infinite; }
        .card-slot.cross-target { border-color: #f39c12 !important; background: rgba(243,156,18,0.3) !important; box-shadow: 0 0 15px rgba(243,156,18,0.6); animation: crossPulse 1s infinite; }
        @keyframes crossPulse { 0%,100% { box-shadow: 0 0 10px rgba(243,156,18,0.4); } 50% { box-shadow: 0 0 25px rgba(243,156,18,0.8); } }
        .card-slot.drag-over { border-color: #f1c40f !important; background: rgba(241,196,15,0.35) !important; box-shadow: 0 0 25px rgba(241,196,15,0.8); }
        .card-slot.moveable { border-color: #3498db !important; background: rgba(52,152,219,0.25) !important; box-shadow: 0 0 15px rgba(52,152,219,0.5); }
        @keyframes validPulse { 0%,100% { box-shadow: 0 0 10px rgba(46,204,113,0.4); } 50% { box-shadow: 0 0 25px rgba(46,204,113,0.8); } }
        
        .trap-slot { width: 50px; height: 50px; margin: auto 0; border: 2px dashed rgba(200,150,200,0.4); border-radius: 50%; background: rgba(200,150,200,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; font-size: 0.55em; color: rgba(255,255,255,0.4); }
        .trap-slot:hover { border-color: #ffd700; background: rgba(255,215,0,0.2); }
        .trap-slot.has-trap { border-style: solid; background: rgba(231,76,60,0.3); border-color: #e74c3c; font-size: 1.3em; color: white; }
        .trap-slot.has-trap.mine { background: rgba(46,204,113,0.3); border-color: #27ae60; }
        .trap-slot.valid-target { border-color: #2ecc71 !important; background: rgba(46,204,113,0.3) !important; }
        .trap-slot.drag-over { border-color: #f1c40f !important; background: rgba(241,196,15,0.4) !important; }
        .trap-slot.triggered { animation: trapExplode 0.6s ease-out; }
        @keyframes trapExplode { 0% { transform: scale(1); } 50% { transform: scale(1.8); background: rgba(255,100,0,0.8); } 100% { transform: scale(0); opacity: 0; } }
        
        .card { width: 86px; height: 116px; border-radius: 6px; position: relative; cursor: grab; overflow: hidden; transition: transform 0.3s, box-shadow 0.2s; background: #111; flex-shrink: 0; }
        .card.dragging { opacity: 0.4; cursor: grabbing; }
        .card-cost { position: absolute; top: 3px; left: 3px; width: 22px; height: 22px; background: radial-gradient(circle at 30% 30%, #4fc3f7, #0277bd); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.85em; font-weight: bold; border: 2px solid #81d4fa; z-index: 5; }
        .card-type-icon { position: absolute; top: 3px; right: 3px; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7em; z-index: 5; }
        .card-type-icon.spell-icon { background: rgba(155,89,182,0.9); border: 2px solid #bb8fce; }
        .card-type-icon.trap-icon { background: rgba(231,76,60,0.9); border: 2px solid #ec7063; }
        .card-art { width: 100%; height: 55px; display: flex; align-items: center; justify-content: center; font-size: 2em; }
        .card.creature .card-art { background: linear-gradient(180deg, #2a3a5a, #151d2e); }
        .card.spell .card-art { background: linear-gradient(180deg, #5a2a6a, #2d1535); }
        .card.trap-card .card-art { background: linear-gradient(180deg, #6a2a2a, #351515); }
        .card-body { background: #0a0a0a; padding: 3px; height: 61px; }
        .card-name { font-size: 0.5em; font-weight: bold; text-align: center; color: #ffd700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-abilities { display: flex; gap: 2px; justify-content: center; font-size: 0.7em; margin: 2px 0; }
        .card-stats { display: flex; justify-content: space-between; padding: 0 5px; margin-top: 2px; }
        .stat { font-size: 0.8em; font-weight: bold; padding: 2px 7px; border-radius: 3px; }
        .stat-atk { background: linear-gradient(135deg, #c0392b, #8e2222); }
        .stat-hp { background: linear-gradient(135deg, #27ae60, #1a7a42); }
        .stat-hp.damaged { background: linear-gradient(135deg, #e67e22, #d35400); }
        .card.creature { border: 3px solid #3498db; }
        .card.spell { border: 3px solid #9b59b6; }
        .card.trap-card { border: 3px solid #e74c3c; }
        .card.just-played { opacity: 0.6; }
        .card.just-played::after { content: 'üí§'; position: absolute; top: 2px; right: 2px; font-size: 0.7em; }
        .card.can-attack { box-shadow: 0 0 10px rgba(231,76,60,0.6); }
        .card.field-selected { box-shadow: 0 0 15px rgba(52,152,219,0.9); border-color: #3498db !important; }
        
        /* ANIMATIONS */
        .card.attacking { animation: attackAnim 0.4s ease-out; }
        @keyframes attackAnim { 0% { transform: translateX(0); } 50% { transform: translateX(30px) scale(1.1); } 100% { transform: translateX(0); } }
        
        .card.taking-damage { animation: damageAnim 0.4s ease-out; }
        @keyframes damageAnim { 0%, 100% { filter: none; } 50% { filter: brightness(2) saturate(0); box-shadow: 0 0 20px red; } }
        
        .card.dying { animation: deathAnim 0.6s ease-out forwards; }
        @keyframes deathAnim { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0) rotate(180deg); opacity: 0; } }
        
        .card.summoning { animation: summonAnim 0.5s ease-out; }
        @keyframes summonAnim { 0% { transform: scale(0) translateY(-50px); opacity: 0; } 100% { transform: scale(1) translateY(0); opacity: 1; } }
        
        .card.healing { animation: healAnim 0.5s ease-out; }
        @keyframes healAnim { 0%, 100% { box-shadow: none; } 50% { box-shadow: 0 0 30px rgba(46,204,113,0.9); } }
        
        /* Carte affich√©e lors des sorts/pi√®ges */
        .card-showcase { 
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%) scale(2); 
            z-index: 2000; 
            animation: showcaseAnim 1.5s ease-out forwards;
            pointer-events: none;
        }
        @keyframes showcaseAnim { 
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 
            20% { opacity: 1; transform: translate(-50%, -50%) scale(2.2); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); } 
        }
        
        /* Vibration pour carte non jouable */
        .card.shake { animation: shakeAnim 0.4s ease-out; }
        @keyframes shakeAnim {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
        }
        
        /* Retour smooth dans la main */
        .card.returning { 
            transition: transform 0.3s ease-out, left 0.3s ease-out, top 0.3s ease-out;
        }
        
        .attack-projectile { position: fixed; z-index: 1000; font-size: 2em; pointer-events: none; transition: all 0.3s ease-out; }
        
        .spell-effect { position: fixed; z-index: 1000; font-size: 3em; pointer-events: none; animation: spellAnim 0.6s ease-out forwards; }
        @keyframes spellAnim { 0% { transform: scale(0); opacity: 1; } 50% { transform: scale(1.5); opacity: 1; } 100% { transform: scale(2); opacity: 0; } }
        
        .spell-miss { position: fixed; z-index: 1000; font-size: 2em; pointer-events: none; animation: missAnim 0.8s ease-out forwards; }
        @keyframes missAnim { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.5) translateY(-30px); opacity: 0; } }
        
        .damage-number { position: fixed; z-index: 1001; font-size: 1.8em; font-weight: bold; color: #e74c3c; text-shadow: 2px 2px 4px black; pointer-events: none; animation: damageFloat 1s ease-out forwards; }
        .damage-number.heal { color: #2ecc71; }
        @keyframes damageFloat { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }
        
        /* MAIN DU JOUEUR - 50% cach√©e (partie inf√©rieure hors √©cran) */
        .my-hand { 
            position: absolute; 
            bottom: -58px; /* Cache 50% de la carte (116px / 2) */
            left: 140px; 
            display: flex; 
            padding: 10px 15px 0 15px;
            background: transparent; 
            max-width: calc(50% - 150px); 
            z-index: 20;
        }
        .my-hand .card { 
            margin-left: -40px; 
            transition: transform 0.2s ease-out, z-index 0s; 
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }
        .my-hand .card:first-child { margin-left: 0; }
        .my-hand .card:hover:not(.dragging) { 
            transform: translateY(-90px) scale(1.15); 
            z-index: 100 !important;
        }
        .my-hand .card.selected { 
            transform: translateY(-100px) scale(1.18); 
            z-index: 101 !important; 
            box-shadow: 0 0 25px rgba(255,215,0,0.8); 
        }
        
        /* MAIN ADVERSE - m√™me taille, 50% cach√©e */
        .opp-hand { 
            position: absolute; 
            bottom: -58px; /* M√™me chose: 50% cach√©e */
            right: 140px; 
            display: flex; 
            padding: 10px 15px 0 15px;
            background: transparent;
            z-index: 20;
        }
        .opp-card-back { 
            width: 86px; /* M√™me taille que les cartes du joueur */
            height: 116px; 
            margin-left: -40px; 
            border-radius: 6px; 
            background: linear-gradient(135deg, #4a3a2a, #2a2015); 
            border: 3px solid #8b7355; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.8em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            flex-shrink: 0;
            transition: transform 0.2s ease-out;
            position: relative;
            z-index: 1;
        }
        .opp-card-back:first-child { margin-left: 0; }
        .opp-card-back:hover {
            transform: translateY(-90px) scale(1.15);
            z-index: 100 !important;
        }
        
        .log-btn { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); padding: 8px 20px; background: rgba(60,50,40,0.9); border: 2px solid #8b7355; border-radius: 20px; cursor: pointer; font-size: 0.75em; z-index: 30; }
        .log-popup { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); width: 400px; max-height: 280px; background: rgba(20,20,40,0.98); border: 2px solid #8b7355; border-radius: 12px; padding: 12px; display: none; z-index: 100; }
        .log-popup.active { display: block; }
        .log-popup h3 { color: #ffd700; margin-bottom: 8px; font-size: 0.85em; text-align: center; }
        .log-content { max-height: 220px; overflow-y: auto; font-size: 0.7em; }
        .log-entry { padding: 4px 8px; margin: 3px 0; border-radius: 4px; }
        .log-phase { background: rgba(255,215,0,0.2); color: #ffd700; }
        .log-action { background: rgba(52,152,219,0.2); color: #5dade2; }
        .log-damage { background: rgba(231,76,60,0.2); color: #ec7063; }
        .log-heal { background: rgba(46,204,113,0.2); color: #58d68d; }
        .log-trap { background: rgba(155,89,182,0.2); color: #bb8fce; }
        
        .game-over { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .game-over.hidden { display: none; }
        .game-over-box { text-align: center; padding: 40px; background: rgba(30,30,50,0.98); border-radius: 15px; border: 4px solid #ffd700; }
        .game-over-title { font-size: 2.5em; color: #ffd700; margin-bottom: 15px; }
        .game-over-result { font-size: 1.3em; margin-bottom: 25px; }
        .game-over-result.victory { color: #2ecc71; }
        .game-over-result.defeat { color: #e74c3c; }
    </style>
</head>
<body>
    <div class="lobby" id="lobby">
        <h1 class="lobby-title">‚öîÔ∏è Bataille des H√©ros</h1>
        <div class="lobby-box" id="lobby-menu">
            <h2 style="margin-bottom:25px;color:#ffd700;">Multijoueur</h2>
            <button class="lobby-btn btn-create" onclick="createRoom()">üéÆ Cr√©er une partie</button>
            <div style="margin:18px 0;color:#666;">‚Äî ou ‚Äî</div>
            <input type="text" class="room-code-input" id="room-code-input" placeholder="CODE" maxlength="6">
            <button class="lobby-btn btn-join" onclick="joinRoom()">üö™ Rejoindre</button>
        </div>
        <div class="lobby-box hidden" id="lobby-waiting">
            <h2 style="color:#ffd700;margin-bottom:15px;">Partie cr√©√©e !</h2>
            <p style="color:#aaa;margin-bottom:8px;">Partagez ce code :</p>
            <div class="room-code-display" id="room-code-display">------</div>
            <p class="waiting-text">‚è≥ En attente d'un adversaire...</p>
        </div>
    </div>

    <div class="game-container" id="game-container">
        <div class="top-bar">
            <div class="player-info-bar">
                <div class="rank-badge">Rang</div>
                <div class="player-name me" id="me-name">Joueur 1</div>
                <div class="energy-display">
                    <div class="mana-orb" id="me-energy">1</div>
                    <span class="energy-text">Mana</span>
                </div>
            </div>
            <div class="header-center">
                <span class="header-timer" id="header-timer">15</span>
            </div>
            <div class="player-info-bar">
                <div class="energy-display">
                    <span class="energy-text">Mana</span>
                    <div class="mana-orb" id="opp-energy">1</div>
                </div>
                <div class="player-name opp" id="opp-name">Joueur 2</div>
                <div class="rank-badge">Rang</div>
                <button class="options-btn">‚öôÔ∏è</button>
            </div>
        </div>
        
        <button class="end-turn-btn" id="end-turn-btn" onclick="endTurn()">
            <span style="font-size:1.2em;">‚öîÔ∏è</span>
            <span>FIN DU</span>
            <span>TOUR</span>
        </button>
        
        <div class="phase-indicator deploy" id="phase-indicator">üîÑ Phase de Red√©ploiement</div>
        
        <div class="side-panel left">
            <div class="hero-card" id="hero-me">
                <div class="ready-dot" id="me-ready"></div>
                <div class="hero-label" id="me-hero-name">Aldric</div>
                <div class="hero-icon" id="me-icon">üßô‚Äç‚ôÇÔ∏è</div>
                <div class="hero-hp" id="me-hp">20</div>
            </div>
            <div class="deck-grave-row">
                <div class="deck-box">
                    <div class="deck-icon">üé¥</div>
                    <div class="deck-count" id="me-deck">53</div>
                    <div>DECK</div>
                </div>
                <div class="grave-box">
                    <div class="deck-icon">‚ò†Ô∏è</div>
                    <div class="deck-count" id="me-grave">0</div>
                    <div>CIMETI√àRE</div>
                </div>
            </div>
        </div>
        
        <div class="side-panel right">
            <div class="hero-card" id="hero-opp">
                <div class="ready-dot" id="opp-ready"></div>
                <div class="hero-label" id="opp-hero-name">Lyra</div>
                <div class="hero-icon" id="opp-icon">‚öîÔ∏è</div>
                <div class="hero-hp" id="opp-hp">20</div>
            </div>
            <div class="deck-grave-row">
                <div class="deck-box">
                    <div class="deck-icon">üé¥</div>
                    <div class="deck-count" id="opp-deck">53</div>
                    <div>DECK</div>
                </div>
                <div class="grave-box">
                    <div class="deck-icon">‚ò†Ô∏è</div>
                    <div class="deck-count" id="opp-grave">0</div>
                    <div>CIMETI√àRE</div>
                </div>
            </div>
        </div>
        
        <div class="battlefield" id="battlefield"></div>
        
        <div class="my-hand" id="my-hand"></div>
        <div class="opp-hand" id="opp-hand"></div>
        
        <div class="log-btn" onclick="toggleLog()">üìú Journal de bataille</div>
        <div class="log-popup" id="log-popup">
            <h3>üìú Journal de Bataille</h3>
            <div class="log-content" id="log-content"></div>
        </div>
    </div>
    
    <div class="game-over hidden" id="game-over">
        <div class="game-over-box">
            <div class="game-over-title">üèÜ Fin de Partie</div>
            <div class="game-over-result" id="result">Victoire !</div>
            <button class="lobby-btn btn-create" onclick="location.reload()">üîÑ Rejouer</button>
        </div>
    </div>

    <script>
        let socket, myNum = 0, state = null;
        let selected = null, dragged = null, draggedFromField = null;
        let currentTimer = 90;
        
        const SLOT_NAMES = [['A', 'B'], ['C', 'D'], ['E', 'F'], ['G', 'H']];
        
        function initSocket() {
            socket = io();
            
            socket.on('gameStart', (s) => {
                state = s;
                myNum = s.myPlayer;
                setupHeroes();
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('game-container').classList.add('active');
                buildBattlefield();
                render();
                log('üéÆ Tour 1 - Partie lanc√©e !', 'phase');
                
                // Message √©ph√©m√®re initial
                showPhaseMessage('üîÑ Phase de Red√©ploiement', 'redeploy');
            });
            
            socket.on('gameStateUpdate', (s) => {
                const wasInDeployPhase = state?.me?.inDeployPhase;
                state = s;
                render();
                updatePhaseDisplay();
                
                // Message √©ph√©m√®re si on vient de passer en phase de d√©ploiement
                if (!wasInDeployPhase && state.me.inDeployPhase && state.phase === 'planning') {
                    showPhaseMessage('üé¥ Phase de D√©ploiement', 'deploy');
                }
            });
            
            socket.on('timerUpdate', (t) => { 
                currentTimer = t;
                if(state) state.timeLeft = t;
                updateTimerDisplay(t);
            });
            
            socket.on('phaseChange', (p) => {
                if(state) state.phase = p; 
                updatePhaseDisplay();
            });
            
            socket.on('phaseMessage', (data) => {
                showPhaseMessage(data.text, data.type);
            });
            
            socket.on('playerReady', (n) => {
                const isMe = n === myNum;
                document.getElementById(isMe ? 'me-ready' : 'opp-ready').classList.add('ready');
                document.getElementById(isMe ? 'me-ready' : 'opp-ready').textContent = '‚úì';
                if (isMe) {
                    document.getElementById('end-turn-btn').classList.add('waiting');
                }
                log(isMe ? 'Vous √™tes pr√™t' : 'Adversaire pr√™t', 'action');
            });
            
            socket.on('newTurn', (d) => {
                currentTimer = 90;
                document.getElementById('me-ready').classList.remove('ready');
                document.getElementById('opp-ready').classList.remove('ready');
                document.getElementById('me-ready').textContent = '';
                document.getElementById('opp-ready').textContent = '';
                document.getElementById('end-turn-btn').classList.remove('waiting');
                clearSel();
                updateTimerDisplay(90);
                log(`üéÆ Tour ${d.turn} ‚Äî ‚ö°${d.maxEnergy} √©nergie`, 'phase');
                
                // Message √©ph√©m√®re de phase
                showPhaseMessage('üîÑ Phase de Red√©ploiement', 'redeploy');
            });
            
            socket.on('resolutionLog', (d) => log(d.msg, d.type));
            
            socket.on('directDamage', (d) => {
                const heroEl = document.getElementById(d.defender === myNum ? 'hero-me' : 'hero-opp');
                heroEl.classList.add('hit');
                setTimeout(() => heroEl.classList.remove('hit'), 500);
            });
            
            socket.on('animation', handleAnimation);
            
            socket.on('gameOver', (d) => {
                const won = d.winner === myNum;
                document.getElementById('result').textContent = won ? 'üéâ Victoire !' : 'üò¢ D√©faite';
                document.getElementById('result').className = 'game-over-result ' + (won ? 'victory' : 'defeat');
                document.getElementById('game-over').classList.remove('hidden');
            });
            
            socket.on('playerDisconnected', () => log('‚ö†Ô∏è Adversaire d√©connect√©', 'damage'));
        }
        
        function handleAnimation(data) {
            const { type } = data;
            switch(type) {
                case 'attack': animateAttack(data); break;
                case 'damage': animateDamage(data); break;
                case 'death': animateDeath(data); break;
                case 'spell': animateSpell(data); break;
                case 'spellMiss': animateSpellMiss(data); break;
                case 'heal': animateHeal(data); break;
                case 'trapTrigger': animateTrap(data); break;
                case 'summon': animateSummon(data); break;
                case 'heroHit':
                    const heroEl = document.getElementById(data.defender === myNum ? 'hero-me' : 'hero-opp');
                    heroEl.classList.add('hit');
                    setTimeout(() => heroEl.classList.remove('hit'), 500);
                    break;
            }
        }
        
        function animateAttack(data) {
            const owner = data.attacker === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            const card = slot?.querySelector('.card');
            if (card) {
                card.classList.add('attacking');
                setTimeout(() => card.classList.remove('attacking'), 400);
            }
            
            if (slot) {
                const rect = slot.getBoundingClientRect();
                const projectile = document.createElement('div');
                projectile.className = 'attack-projectile';
                projectile.textContent = data.isShooter ? 'üèπ' : data.isFlying ? 'üí®' : '‚öîÔ∏è';
                projectile.style.left = rect.left + rect.width/2 + 'px';
                projectile.style.top = rect.top + rect.height/2 + 'px';
                document.body.appendChild(projectile);
                
                const targetOwner = data.targetPlayer === myNum ? 'me' : 'opp';
                let targetX, targetY;
                
                if (data.targetCol === -1) {
                    const heroEl = document.getElementById(targetOwner === 'me' ? 'hero-me' : 'hero-opp');
                    const heroRect = heroEl.getBoundingClientRect();
                    targetX = heroRect.left + heroRect.width/2;
                    targetY = heroRect.top + heroRect.height/2;
                } else {
                    const targetSlot = document.querySelector(`.card-slot[data-owner="${targetOwner}"][data-row="${data.targetRow}"][data-col="${data.targetCol}"]`);
                    if (targetSlot) {
                        const targetRect = targetSlot.getBoundingClientRect();
                        targetX = targetRect.left + targetRect.width/2;
                        targetY = targetRect.top + targetRect.height/2;
                    }
                }
                
                if (targetX && targetY) {
                    setTimeout(() => {
                        projectile.style.left = targetX + 'px';
                        projectile.style.top = targetY + 'px';
                        projectile.style.transform = 'scale(1.5)';
                    }, 50);
                }
                setTimeout(() => projectile.remove(), 350);
            }
        }
        
        function animateDamage(data) {
            const owner = data.player === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            const card = slot?.querySelector('.card');
            if (card) {
                card.classList.add('taking-damage');
                setTimeout(() => card.classList.remove('taking-damage'), 400);
            }
            
            if (slot) {
                const rect = slot.getBoundingClientRect();
                const num = document.createElement('div');
                num.className = 'damage-number';
                num.textContent = `-${data.amount}`;
                num.style.left = rect.left + rect.width/2 - 20 + 'px';
                num.style.top = rect.top + 'px';
                document.body.appendChild(num);
                setTimeout(() => num.remove(), 1000);
            }
        }
        
        function animateDeath(data) {
            const owner = data.player === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            const card = slot?.querySelector('.card');
            if (card) card.classList.add('dying');
        }
        
        function animateSpell(data) {
            // Afficher la carte du sort
            if (data.spell) {
                showCardShowcase(data.spell);
            }
            
            const targetOwner = data.targetPlayer === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${targetOwner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            if (slot) {
                const rect = slot.getBoundingClientRect();
                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.textContent = data.spell.icon || '‚ú®';
                effect.style.left = rect.left + rect.width/2 - 30 + 'px';
                effect.style.top = rect.top + rect.height/2 - 30 + 'px';
                document.body.appendChild(effect);
                setTimeout(() => effect.remove(), 600);
            }
        }
        
        function animateSpellMiss(data) {
            const targetOwner = data.targetPlayer === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${targetOwner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            if (slot) {
                const rect = slot.getBoundingClientRect();
                const effect = document.createElement('div');
                effect.className = 'spell-miss';
                effect.textContent = 'üí®';
                effect.style.left = rect.left + rect.width/2 - 20 + 'px';
                effect.style.top = rect.top + rect.height/2 - 20 + 'px';
                document.body.appendChild(effect);
                setTimeout(() => effect.remove(), 800);
            }
        }
        
        function animateHeal(data) {
            const owner = data.player === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            const card = slot?.querySelector('.card');
            if (card) {
                card.classList.add('healing');
                setTimeout(() => card.classList.remove('healing'), 500);
            }
            if (slot) {
                const rect = slot.getBoundingClientRect();
                const num = document.createElement('div');
                num.className = 'damage-number heal';
                num.textContent = `+${data.amount}`;
                num.style.left = rect.left + rect.width/2 - 20 + 'px';
                num.style.top = rect.top + 'px';
                document.body.appendChild(num);
                setTimeout(() => num.remove(), 1000);
            }
        }
        
        function animateTrap(data) {
            // Afficher la carte du pi√®ge
            if (data.trap) {
                showCardShowcase(data.trap);
            }
            
            const owner = data.player === myNum ? 'me' : 'opp';
            const trapSlot = document.querySelector(`.trap-slot[data-owner="${owner}"][data-row="${data.row}"]`);
            if (trapSlot) {
                trapSlot.classList.add('triggered');
                const rect = trapSlot.getBoundingClientRect();
                const effect = document.createElement('div');
                effect.className = 'spell-effect';
                effect.textContent = 'üí•';
                effect.style.left = rect.left + rect.width/2 - 30 + 'px';
                effect.style.top = rect.top + rect.height/2 - 30 + 'px';
                document.body.appendChild(effect);
                setTimeout(() => effect.remove(), 600);
                setTimeout(() => trapSlot.classList.remove('triggered'), 600);
            }
        }
        
        function animateSummon(data) {
            // N'animer que les cr√©atures de l'adversaire (pas les n√¥tres, on sait d√©j√† qu'on les a pos√©es)
            if (data.animateForOpponent && data.player === myNum) {
                return; // C'est notre cr√©ature, pas d'animation
            }
            
            const owner = data.player === myNum ? 'me' : 'opp';
            const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${data.row}"][data-col="${data.col}"]`);
            
            // Attendre que le DOM soit mis √† jour puis animer
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const card = slot?.querySelector('.card');
                    if (card) {
                        // Forcer l'√©tat initial
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0) translateY(-50px)';
                        
                        // D√©clencher l'animation apr√®s un micro-d√©lai
                        setTimeout(() => {
                            card.style.opacity = '';
                            card.style.transform = '';
                            card.classList.add('summoning');
                            setTimeout(() => card.classList.remove('summoning'), 500);
                        }, 20);
                    }
                });
            });
        }
        
        // Afficher une carte √† l'√©cran (pour sorts et pi√®ges)
        function showCardShowcase(card) {
            const cardEl = makeCard(card, false);
            cardEl.classList.add('card-showcase');
            document.body.appendChild(cardEl);
            
            setTimeout(() => {
                cardEl.remove();
            }, 1500);
        }
        
        function canPlay() {
            if (!state) return false;
            if (state.phase !== 'planning') return false;
            if (state.me.ready) return false;
            return true;
        }
        
        function updateTimerDisplay(t) {
            const timerEl = document.getElementById('header-timer');
            
            if (t <= 15 && state && state.phase === 'planning') {
                timerEl.classList.add('visible');
                timerEl.textContent = t;
                timerEl.classList.toggle('urgent', t <= 5);
            } else {
                timerEl.classList.remove('visible', 'urgent');
            }
        }
        
        function showPhaseMessage(text, type) {
            const el = document.getElementById('phase-indicator');
            el.textContent = text;
            el.className = 'phase-indicator ' + type;
            el.classList.remove('fade-out');
            
            // Message √©ph√©m√®re sauf pour resolution
            if (type !== 'resolution') {
                setTimeout(() => {
                    el.classList.add('fade-out');
                }, 2000);
            }
        }
        
        function updatePhaseDisplay() {
            if (!state) return;
            
            if (state.phase === 'resolution') {
                showPhaseMessage('‚öîÔ∏è R√©solution du Combat', 'resolution');
            }
            // Les autres phases sont g√©r√©es par showPhaseMessage appel√© manuellement
        }
        
        function setupHeroes() {
            document.getElementById('me-name').textContent = state.me.heroName + ' (Vous)';
            document.getElementById('opp-name').textContent = state.opponent.heroName;
            document.getElementById('me-hero-name').textContent = state.me.heroName;
            document.getElementById('opp-hero-name').textContent = state.opponent.heroName;
            document.getElementById('me-icon').textContent = myNum === 1 ? 'üßô‚Äç‚ôÇÔ∏è' : '‚öîÔ∏è';
            document.getElementById('opp-icon').textContent = myNum === 1 ? '‚öîÔ∏è' : 'üßô‚Äç‚ôÇÔ∏è';
        }
        
        function createRoom() {
            socket.emit('createRoom', (r) => {
                if (r.success) {
                    myNum = r.playerNum;
                    document.getElementById('room-code-display').textContent = r.code;
                    document.getElementById('lobby-menu').classList.add('hidden');
                    document.getElementById('lobby-waiting').classList.remove('hidden');
                }
            });
        }
        
        function joinRoom() {
            const code = document.getElementById('room-code-input').value.trim();
            if (!code) return;
            socket.emit('joinRoom', code, (r) => {
                if (r.success) myNum = r.playerNum;
                else alert(r.error);
            });
        }
        
        function buildBattlefield() {
            const bf = document.getElementById('battlefield');
            bf.innerHTML = '';
            
            const myField = document.createElement('div');
            myField.className = 'field-side';
            for (let row = 0; row < 4; row++) {
                myField.appendChild(makeSlot('me', row, 0));
                myField.appendChild(makeSlot('me', row, 1));
            }
            bf.appendChild(myField);
            
            const trapCenter = document.createElement('div');
            trapCenter.className = 'trap-center';
            
            const myTraps = document.createElement('div');
            myTraps.className = 'trap-col';
            for (let i = 0; i < 4; i++) myTraps.appendChild(makeTrapSlot('me', i));
            
            const oppTraps = document.createElement('div');
            oppTraps.className = 'trap-col';
            for (let i = 0; i < 4; i++) oppTraps.appendChild(makeTrapSlot('opp', i));
            
            trapCenter.appendChild(myTraps);
            trapCenter.appendChild(oppTraps);
            bf.appendChild(trapCenter);
            
            const oppField = document.createElement('div');
            oppField.className = 'field-side';
            for (let row = 0; row < 4; row++) {
                oppField.appendChild(makeSlot('opp', row, 1));
                oppField.appendChild(makeSlot('opp', row, 0));
            }
            bf.appendChild(oppField);
        }
        
        function makeSlot(owner, row, col) {
            const el = document.createElement('div');
            const suffix = owner === 'me' ? '1' : '2';
            const label = SLOT_NAMES[row][col] + suffix;
            
            el.className = `card-slot ${owner}-slot`;
            el.dataset.owner = owner;
            el.dataset.row = row;
            el.dataset.col = col;
            el.innerHTML = `<span class="slot-label">${label}</span>`;
            
            el.onclick = () => clickSlot(owner, row, col);
            
            // Pr√©visualisation du sort croix au survol
            el.onmouseenter = () => {
                if (selected && selected.fromHand && selected.type === 'spell' && selected.pattern === 'cross') {
                    if (el.classList.contains('valid-target')) {
                        previewCrossTargets(owner, row, col);
                    }
                }
            };
            el.onmouseleave = () => {
                document.querySelectorAll('.card-slot.cross-target').forEach(s => s.classList.remove('cross-target'));
            };
            
            el.ondragover = (e) => { 
                e.preventDefault(); 
                if (el.classList.contains('valid-target') || el.classList.contains('moveable')) {
                    el.classList.add('drag-over');
                }
                // Pr√©visualisation croix au drag
                if (dragged && dragged.type === 'spell' && dragged.pattern === 'cross' && el.classList.contains('valid-target')) {
                    previewCrossTargets(owner, row, col);
                }
            };
            el.ondragleave = () => {
                el.classList.remove('drag-over');
                document.querySelectorAll('.card-slot.cross-target').forEach(s => s.classList.remove('cross-target'));
            };
            el.ondrop = (e) => { 
                e.preventDefault(); 
                el.classList.remove('drag-over');
                
                // Drop from field (redeploy)
                if (draggedFromField) {
                    if (el.classList.contains('moveable')) {
                        socket.emit('moveCard', { 
                            fromRow: draggedFromField.row, 
                            fromCol: draggedFromField.col, 
                            toRow: parseInt(el.dataset.row), 
                            toCol: parseInt(el.dataset.col) 
                        });
                    }
                    clearSel();
                    return;
                }
                
                // Drop from hand
                if (el.classList.contains('valid-target')) {
                    dropOnSlot(owner, row, col);
                }
            };
            return el;
        }
        
        function makeTrapSlot(owner, row) {
            const el = document.createElement('div');
            el.className = 'trap-slot';
            el.dataset.owner = owner;
            el.dataset.row = row;
            el.textContent = 'Pi√®ge';
            
            el.onclick = () => clickTrap(owner, row);
            el.ondragover = (e) => { 
                e.preventDefault(); 
                if (el.classList.contains('valid-target')) el.classList.add('drag-over');
            };
            el.ondragleave = () => el.classList.remove('drag-over');
            el.ondrop = (e) => { 
                e.preventDefault(); 
                el.classList.remove('drag-over'); 
                if (el.classList.contains('valid-target')) dropOnTrap(owner, row);
            };
            return el;
        }
        
        function canPlaceAt(card, col) {
            if (!card || card.type !== 'creature') return false;
            const shooter = card.abilities?.includes('shooter');
            const fly = card.abilities?.includes('fly');
            if (fly) return true;
            if (shooter) return col === 0;
            return col === 1;
        }
        
        function getValidSlots(card) {
            const valid = [];
            if (!card || !state) return valid;
            
            if (card.type === 'creature') {
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 2; col++) {
                        if (canPlaceAt(card, col) && !state.me.field[row][col]) {
                            valid.push({ row, col });
                        }
                    }
                }
            } else if (card.type === 'trap') {
                for (let row = 0; row < 4; row++) {
                    if (!state.me.traps[row]) valid.push({ trap: true, row });
                }
            } else if (card.type === 'spell') {
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 2; col++) {
                        valid.push({ owner: 'me', row, col });
                        valid.push({ owner: 'opp', row, col });
                    }
                }
            }
            return valid;
        }
        
        function highlightValidSlots(card, forceShow = false) {
            clearHighlights();
            if (!card) return;
            // Si la carte est trop ch√®re et qu'on ne force pas l'affichage, ne pas highlight
            // Mais si on drag, on veut montrer o√π √ßa irait (forceShow via le drag)
            if (card.cost > state.me.energy && !forceShow && !dragged) return;
            
            const valid = getValidSlots(card);
            valid.forEach(v => {
                if (v.trap) {
                    const slot = document.querySelector(`.trap-slot[data-owner="me"][data-row="${v.row}"]`);
                    if (slot) slot.classList.add('valid-target');
                } else {
                    const owner = v.owner || 'me';
                    const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${v.row}"][data-col="${v.col}"]`);
                    if (slot) slot.classList.add('valid-target');
                }
            });
        }
        
        // Pr√©visualiser les cibles du sort croix au survol
        function previewCrossTargets(targetOwner, row, col) {
            // Nettoyer les anciennes pr√©visualisations
            document.querySelectorAll('.card-slot.cross-target').forEach(s => s.classList.remove('cross-target'));
            
            const targetPlayer = targetOwner === 'me' ? myNum : (myNum === 1 ? 2 : 1);
            const adjacents = getCrossTargetsClient(targetPlayer, row, col);
            
            adjacents.forEach(t => {
                const owner = t.player === myNum ? 'me' : 'opp';
                const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${t.row}"][data-col="${t.col}"]`);
                if (slot) slot.classList.add('cross-target');
            });
        }
        
        // Version client de getCrossTargets
        function getCrossTargetsClient(targetPlayer, row, col) {
            const targets = [];
            if (row > 0) targets.push({ row: row - 1, col, player: targetPlayer });
            if (row < 3) targets.push({ row: row + 1, col, player: targetPlayer });
            if (col > 0) targets.push({ row, col: col - 1, player: targetPlayer });
            if (col < 1) targets.push({ row, col: col + 1, player: targetPlayer });
            return targets;
        }
        
        function highlightMoveTargets(fromRow, fromCol, card) {
            clearHighlights();
            [fromRow - 1, fromRow + 1].forEach(toRow => {
                if (toRow < 0 || toRow > 3) return;
                if (state.me.field[toRow][fromCol]) return;
                const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${toRow}"][data-col="${fromCol}"]`);
                if (slot) slot.classList.add('moveable');
            });
        }
        
        function clearHighlights() {
            document.querySelectorAll('.card-slot, .trap-slot').forEach(s => {
                s.classList.remove('valid-target', 'drag-over', 'moveable', 'cross-target');
            });
        }
        
        function render() {
            if (!state) return;
            const me = state.me, opp = state.opponent;
            
            document.getElementById('me-hp').textContent = me.hp;
            document.getElementById('opp-hp').textContent = opp.hp;
            document.getElementById('me-energy').textContent = `${me.energy}/${me.maxEnergy}`;
            document.getElementById('opp-energy').textContent = `${opp.energy}/${opp.maxEnergy}`;
            document.getElementById('me-deck').textContent = me.deckCount;
            document.getElementById('opp-deck').textContent = opp.deckCount;
            document.getElementById('me-grave').textContent = me.graveyardCount || 0;
            document.getElementById('opp-grave').textContent = opp.graveyardCount || 0;
            
            renderField('me', me.field);
            renderField('opp', opp.field);
            renderTraps();
            renderHand(me.hand, me.energy);
            renderOppHand(opp.handCount);
            
            if (me.ready) {
                document.getElementById('me-ready').classList.add('ready');
                document.getElementById('me-ready').textContent = '‚úì';
                document.getElementById('end-turn-btn').classList.add('waiting');
            }
            if (opp.ready) {
                document.getElementById('opp-ready').classList.add('ready');
                document.getElementById('opp-ready').textContent = '‚úì';
            }
        }
        
        function renderField(owner, field) {
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 2; c++) {
                    const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${r}"][data-col="${c}"]`);
                    if (!slot) continue;
                    
                    const label = slot.querySelector('.slot-label');
                    slot.innerHTML = '';
                    if (label) slot.appendChild(label.cloneNode(true));
                    
                    slot.classList.remove('has-card');
                    const card = field[r][c];
                    if (card) {
                        slot.classList.add('has-card');
                        const cardEl = makeCard(card, false);
                        
                        // Drag & drop pour red√©ploiement (seulement mes cartes)
                        if (owner === 'me' && !state.me.inDeployPhase && !card.movedThisTurn) {
                            cardEl.draggable = true;
                            cardEl.ondragstart = (e) => {
                                if (!canPlay()) { e.preventDefault(); return; }
                                draggedFromField = { row: r, col: c, card };
                                cardEl.classList.add('dragging');
                                highlightMoveTargets(r, c, card);
                            };
                            cardEl.ondragend = () => {
                                cardEl.classList.remove('dragging');
                                draggedFromField = null;
                                clearHighlights();
                            };
                        }
                        
                        if (owner === 'me') {
                            cardEl.onclick = (e) => { e.stopPropagation(); clickFieldCard(r, c, card); };
                        }
                        slot.appendChild(cardEl);
                    }
                }
            }
        }
        
        function renderTraps() {
            state.me.traps.forEach((trap, i) => {
                const slot = document.querySelector(`.trap-slot[data-owner="me"][data-row="${i}"]`);
                if (slot) {
                    slot.classList.remove('has-trap', 'mine');
                    if (trap) {
                        slot.classList.add('has-trap', 'mine');
                        slot.textContent = 'üí£';
                    } else {
                        slot.textContent = 'Pi√®ge';
                    }
                }
            });
            
            state.opponent.traps.forEach((trap, i) => {
                const slot = document.querySelector(`.trap-slot[data-owner="opp"][data-row="${i}"]`);
                if (slot) {
                    slot.classList.remove('has-trap', 'mine');
                    if (trap) {
                        slot.classList.add('has-trap');
                        slot.textContent = '‚ùì';
                    } else {
                        slot.textContent = 'Pi√®ge';
                    }
                }
            });
        }
        
        function renderHand(hand, energy) {
            const panel = document.getElementById('my-hand');
            panel.innerHTML = '';
            hand.forEach((card, i) => {
                const el = makeCard(card, true);
                el.dataset.idx = i;
                el.dataset.cost = card.cost;
                
                // Z-index incr√©mental pour √©viter les saccades au hover
                el.style.zIndex = i + 1;
                
                // Toujours draggable
                el.draggable = true;
                
                el.onclick = (e) => { e.stopPropagation(); selectCard(i); };
                
                el.ondragstart = (e) => {
                    if (!canPlay()) { e.preventDefault(); return; }
                    
                    // Stocker si la carte est trop ch√®re
                    const tooExpensive = card.cost > energy;
                    
                    dragged = { ...card, idx: i, tooExpensive };
                    draggedFromField = null;
                    el.classList.add('dragging');
                    
                    // Highlight m√™me si trop cher (pour montrer o√π √ßa irait)
                    highlightValidSlots(card);
                };
                el.ondragend = (e) => {
                    el.classList.remove('dragging');
                    
                    // Si on a essay√© de poser une carte trop ch√®re, faire vibrer
                    if (dragged && dragged.tooExpensive && dragged.triedToDrop) {
                        el.classList.add('shake');
                        setTimeout(() => el.classList.remove('shake'), 400);
                    }
                    
                    dragged = null;
                    clearHighlights();
                };
                
                panel.appendChild(el);
            });
        }
        
        function renderOppHand(count) {
            const panel = document.getElementById('opp-hand');
            panel.innerHTML = '';
            for (let i = 0; i < Math.min(count, 12); i++) {
                const el = document.createElement('div');
                el.className = 'opp-card-back';
                el.textContent = 'üé¥';
                el.style.zIndex = i + 1; // Z-index incr√©mental
                panel.appendChild(el);
            }
        }
        
        function makeCard(card, inHand) {
            const el = document.createElement('div');
            el.className = `card ${card.type === 'trap' ? 'trap-card' : card.type}`;
            
            if (!inHand && card.type === 'creature') {
                if (card.turnsOnField === 0 && !card.abilities?.includes('haste')) el.classList.add('just-played');
                if (card.canAttack) el.classList.add('can-attack');
            }
            
            const icons = { fly: 'ü¶Ö', shooter: 'üéØ', haste: '‚ö°' };
            const abilities = (card.abilities || []).map(a => icons[a] || '').join(' ');
            const hp = card.currentHp ?? card.hp;
            const hpClass = card.type === 'creature' && hp < card.hp ? 'damaged' : '';
            
            // Type icon for spells and traps
            let typeIcon = '';
            if (card.type === 'spell') {
                typeIcon = `<div class="card-type-icon spell-icon">‚ú®</div>`;
            } else if (card.type === 'trap') {
                typeIcon = `<div class="card-type-icon trap-icon">ü™§</div>`;
            }
            
            // Pattern info for cross spell
            let patternInfo = '';
            if (card.pattern === 'cross') {
                patternInfo = '<div style="font-size:0.5em;color:#ff9800;">‚úùÔ∏è Zone</div>';
            }
            
            el.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                ${typeIcon}
                <div class="card-art">${card.icon || '‚ùì'}</div>
                <div class="card-body">
                    <div class="card-name">${card.name}</div>
                    <div class="card-abilities">${abilities || (card.type === 'spell' ? (card.offensive ? '‚öîÔ∏è' : 'üíö') : '')}${patternInfo}</div>
                    <div class="card-stats">
                        ${card.atk !== undefined ? `<span class="stat stat-atk">${card.atk}</span>` : ''}
                        ${card.damage ? `<span class="stat stat-atk">${card.damage}</span>` : ''}
                        ${card.heal ? `<span class="stat stat-hp">${card.heal}</span>` : ''}
                        ${card.type === 'creature' ? `<span class="stat stat-hp ${hpClass}">${hp}</span>` : ''}
                    </div>
                </div>`;
            return el;
        }
        
        function selectCard(i) {
            if (!canPlay()) return;
            const card = state.me.hand[i];
            if (card.cost > state.me.energy) return;
            
            clearSel();
            selected = { ...card, idx: i, fromHand: true };
            document.querySelectorAll('.my-hand .card')[i]?.classList.add('selected');
            highlightValidSlots(card);
        }
        
        function clickFieldCard(row, col, card) {
            if (!canPlay()) return;
            if (state.me.inDeployPhase) return;
            if (card.movedThisTurn) return;
            
            clearSel();
            selected = { ...card, fromField: true, row, col };
            
            const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${row}"][data-col="${col}"]`);
            const cardEl = slot?.querySelector('.card');
            if (cardEl) cardEl.classList.add('field-selected');
            
            highlightMoveTargets(row, col, card);
        }
        
        function clickSlot(owner, row, col) {
            if (!canPlay()) return;
            
            if (selected && selected.fromHand && selected.type === 'spell') {
                const targetPlayer = owner === 'me' ? myNum : (myNum === 1 ? 2 : 1);
                socket.emit('castSpell', { handIndex: selected.idx, targetPlayer, row, col });
                clearSel();
                return;
            }
            
            if (owner !== 'me') return;
            
            if (selected && selected.fromHand && selected.type === 'creature') {
                if (canPlaceAt(selected, col) && !state.me.field[row][col]) {
                    socket.emit('placeCard', { handIndex: selected.idx, row, col });
                    clearSel();
                }
                return;
            }
            
            if (selected && selected.fromField) {
                const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${row}"][data-col="${col}"]`);
                if (slot && slot.classList.contains('moveable')) {
                    socket.emit('moveCard', { fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col });
                    clearSel();
                    return;
                }
            }
            
            const card = state.me.field[row][col];
            if (card && !state.me.inDeployPhase && !card.movedThisTurn) {
                clickFieldCard(row, col, card);
            }
        }
        
        function clickTrap(owner, row) {
            if (!canPlay() || owner !== 'me') return;
            if (selected && selected.fromHand && selected.type === 'trap') {
                if (!state.me.traps[row]) {
                    socket.emit('placeTrap', { handIndex: selected.idx, trapIndex: row });
                    clearSel();
                }
            }
        }
        
        function dropOnSlot(owner, row, col) {
            if (!dragged || !canPlay()) return;
            
            // Si la carte est trop ch√®re, marquer qu'on a essay√© et ne rien faire
            if (dragged.tooExpensive) {
                dragged.triedToDrop = true;
                return;
            }
            
            if (dragged.type === 'spell') {
                const targetPlayer = owner === 'me' ? myNum : (myNum === 1 ? 2 : 1);
                socket.emit('castSpell', { handIndex: dragged.idx, targetPlayer, row, col });
            } else if (dragged.type === 'creature' && owner === 'me') {
                if (canPlaceAt(dragged, col) && !state.me.field[row][col]) {
                    socket.emit('placeCard', { handIndex: dragged.idx, row, col });
                }
            }
            clearSel();
        }
        
        function dropOnTrap(owner, row) {
            if (!dragged || !canPlay() || owner !== 'me') return;
            
            // Si la carte est trop ch√®re, marquer qu'on a essay√© et ne rien faire
            if (dragged.tooExpensive) {
                dragged.triedToDrop = true;
                return;
            }
            
            if (dragged.type === 'trap' && !state.me.traps[row]) {
                socket.emit('placeTrap', { handIndex: dragged.idx, trapIndex: row });
            }
            clearSel();
        }
        
        function endTurn() {
            if (!canPlay()) return;
            document.getElementById('end-turn-btn').classList.add('waiting');
            socket.emit('ready');
        }
        
        function clearSel() {
            selected = null;
            dragged = null;
            draggedFromField = null;
            document.querySelectorAll('.card').forEach(e => e.classList.remove('selected', 'field-selected'));
            clearHighlights();
        }
        
        function toggleLog() {
            document.getElementById('log-popup').classList.toggle('active');
        }
        
        function log(msg, type = 'action') {
            const el = document.createElement('div');
            el.className = `log-entry log-${type}`;
            el.textContent = msg;
            const c = document.getElementById('log-content');
            c.appendChild(el);
            c.scrollTop = c.scrollHeight;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initSocket();
            document.getElementById('room-code-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.card') && !e.target.closest('.card-slot') && !e.target.closest('.trap-slot')) {
                    clearSel();
                }
            });
        });
    </script>
</body>
</html>
