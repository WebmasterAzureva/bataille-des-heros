<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è Bataille des H√©ros</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Cinzel', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }
        
        /* LOBBY */
        .lobby { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; padding: 20px; }
        .lobby.hidden { display: none; }
        .lobby-title { font-size: 3em; color: #ffd700; text-shadow: 0 0 30px rgba(255,215,0,0.5); margin-bottom: 30px; }
        .lobby-box { background: rgba(20,20,40,0.95); padding: 35px; border-radius: 15px; border: 3px solid #8b7355; text-align: center; min-width: 380px; }
        .lobby-btn { display: block; width: 100%; padding: 16px; margin: 12px 0; font-size: 1.1em; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s; font-family: 'Cinzel', serif; }
        .lobby-btn:hover { transform: scale(1.05); }
        .btn-create { background: linear-gradient(135deg, #8b4513, #cd853f); color: white; }
        .btn-join { background: linear-gradient(135deg, #2e4a2e, #4a7c4a); color: white; }
        .room-code-input { width: 100%; padding: 14px; font-size: 1.6em; text-align: center; border: 3px solid #8b7355; border-radius: 8px; background: rgba(0,0,0,0.5); color: #ffd700; margin: 12px 0; text-transform: uppercase; letter-spacing: 8px; }
        .room-code-display { font-size: 2.5em; color: #ffd700; letter-spacing: 10px; margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 8px; }
        .waiting-text { color: #aaa; animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        /* GAME */
        .game-container { width: 100vw; height: 100vh; display: none; position: relative; }
        .game-container.active { display: block; }
        
        /* TOP BAR */
        .top-bar { position: absolute; top: 0; left: 0; right: 0; height: 50px; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; background: rgba(20,20,40,0.95); border-bottom: 2px solid #5a4a3a; z-index: 50; }
        .player-info-bar { display: flex; align-items: center; gap: 12px; }
        .player-name { font-size: 0.95em; padding: 6px 15px; border-radius: 5px; }
        .player-name.me { background: linear-gradient(135deg, #2a4a2a, #1a3a1a); border: 2px solid #4a7c4a; }
        .player-name.opp { background: linear-gradient(135deg, #4a2a2a, #3a1a1a); border: 2px solid #7c4a4a; }
        .energy-orb { width: 42px; height: 42px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #4fc3f7, #0288d1); border: 3px solid #29b6f6; display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: bold; }
        
        /* END TURN BUTTON */
        .end-turn-btn { position: absolute; top: 3px; left: 50%; transform: translateX(-50%); width: 85px; height: 85px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #ff6b35, #c41e00); border: 4px solid #ffd700; cursor: pointer; font-size: 0.6em; font-weight: bold; color: white; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: all 0.3s; }
        .end-turn-btn:hover { transform: translateX(-50%) scale(1.1); }
        .end-turn-btn:disabled { background: radial-gradient(circle at 30% 30%, #555, #333); border-color: #666; cursor: not-allowed; }
        .end-turn-btn.waiting { background: radial-gradient(circle at 30% 30%, #666, #444); }
        .timer-text { font-size: 1.8em; margin-top: 2px; }
        
        /* PHASE INDICATOR */
        .phase-indicator { position: absolute; top: 95px; left: 50%; transform: translateX(-50%); padding: 8px 25px; background: rgba(46,204,113,0.9); border-radius: 20px; border: 2px solid #58d68d; font-size: 0.85em; z-index: 90; white-space: nowrap; }
        .phase-indicator.redeploy { background: rgba(52,152,219,0.9); border-color: #5dade2; }
        .phase-indicator.deploy { background: rgba(46,204,113,0.9); border-color: #58d68d; }
        .phase-indicator.resolution { background: rgba(231,76,60,0.9); border-color: #ec7063; }
        
        /* HERO ZONES */
        .hero-zone { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .hero-zone.me { left: 15px; }
        .hero-zone.opp { right: 15px; }
        .hero-card { width: 85px; height: 110px; border-radius: 8px; background: linear-gradient(135deg, #2a2a4a, #1a1a2a); border: 3px solid #8b7355; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .hero-zone.me .hero-card { border-color: #4a7c4a; }
        .hero-zone.opp .hero-card { border-color: #7c4a4a; }
        .hero-icon { font-size: 2.2em; }
        .hero-name { font-size: 0.6em; margin-top: 2px; }
        .hero-hp { position: absolute; bottom: -12px; left: 50%; transform: translateX(-50%); background: radial-gradient(circle at 30% 30%, #e74c3c, #922b21); width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.1em; font-weight: bold; border: 3px solid #f5b7b1; }
        .ready-dot { position: absolute; top: -5px; right: -5px; width: 18px; height: 18px; border-radius: 50%; background: #7f8c8d; border: 2px solid white; font-size: 0.5em; display: flex; align-items: center; justify-content: center; }
        .ready-dot.ready { background: #27ae60; }
        .deck-pile { width: 60px; height: 85px; position: relative; margin-top: 12px; }
        .deck-card-back { position: absolute; width: 100%; height: 100%; border-radius: 5px; background: linear-gradient(135deg, #4a3a2a, #2a2015); border: 2px solid #8b7355; display: flex; align-items: center; justify-content: center; font-size: 1.2em; }
        .deck-card-back:nth-child(1) { top: 0; left: 0; }
        .deck-card-back:nth-child(2) { top: 2px; left: 2px; }
        .deck-card-back:nth-child(3) { top: 4px; left: 4px; }
        .deck-count { font-size: 0.65em; color: #aaa; margin-top: 8px; text-transform: uppercase; }
        
        /* BATTLEFIELD */
        .battlefield { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; gap: 20px; padding: 12px; background: rgba(0,0,0,0.4); border-radius: 12px; border: 2px solid rgba(139,115,85,0.4); }
        .bf-side { display: grid; grid-template-columns: repeat(2, 115px); grid-template-rows: repeat(4, 155px); gap: 5px; }
        .trap-col { display: flex; flex-direction: column; gap: 12px; justify-content: center; }
        
        /* CARD SLOT */
        .card-slot { width: 115px; height: 155px; border: 2px dashed rgba(255,255,255,0.2); border-radius: 8px; background: rgba(255,255,255,0.02); cursor: pointer; transition: all 0.2s; position: relative; }
        .card-slot:hover { border-color: rgba(255,215,0,0.5); background: rgba(255,215,0,0.1); }
        .card-slot.me-slot { border-color: rgba(74,124,74,0.5); }
        .card-slot.opp-slot { border-color: rgba(124,74,74,0.5); }
        .card-slot.has-card { border-color: transparent; background: transparent; }
        .card-slot.drag-over { border-color: #2ecc71 !important; background: rgba(46,204,113,0.3) !important; box-shadow: 0 0 20px rgba(46,204,113,0.6); }
        .card-slot.targetable { border-color: #e74c3c !important; animation: glow 1s infinite; }
        .card-slot.moveable { border-color: #3498db !important; background: rgba(52,152,219,0.2) !important; }
        @keyframes glow { 0%,100% { box-shadow: 0 0 5px #e74c3c; } 50% { box-shadow: 0 0 20px #e74c3c; } }
        
        /* TRAP SLOT */
        .trap-slot { width: 48px; height: 48px; border: 2px dashed rgba(255,255,255,0.3); transform: rotate(45deg); cursor: pointer; background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .trap-slot:hover { border-color: #ffd700; background: rgba(255,215,0,0.2); }
        .trap-inner { transform: rotate(-45deg); font-size: 1.1em; }
        .trap-slot.has-trap { border-style: solid; background: rgba(231,76,60,0.4); border-color: #e74c3c; }
        .trap-slot.drag-over { border-color: #2ecc71 !important; background: rgba(46,204,113,0.3) !important; }
        
        /* CARDS */
        .card { width: 110px; height: 150px; border-radius: 8px; position: relative; cursor: grab; overflow: hidden; transition: transform 0.2s, box-shadow 0.2s, z-index 0s; background: #111; flex-shrink: 0; }
        .card.dragging { opacity: 0.4; }
        .card-cost { position: absolute; top: 4px; left: 4px; width: 26px; height: 26px; background: radial-gradient(circle at 30% 30%, #4fc3f7, #0277bd); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.95em; font-weight: bold; border: 2px solid #81d4fa; z-index: 5; }
        .card-art { width: 100%; height: 72px; display: flex; align-items: center; justify-content: center; font-size: 2.6em; }
        .card.creature .card-art { background: linear-gradient(180deg, #2a3a5a, #151d2e); }
        .card.spell .card-art { background: linear-gradient(180deg, #5a2a6a, #2d1535); }
        .card.trap-card .card-art { background: linear-gradient(180deg, #6a2a2a, #351515); }
        .card-body { background: #0a0a0a; padding: 5px; height: 78px; }
        .card-name { font-size: 0.6em; font-weight: bold; text-align: center; color: #ffd700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-abilities { display: flex; gap: 2px; justify-content: center; font-size: 0.8em; margin: 3px 0; }
        .card-stats { display: flex; justify-content: space-between; padding: 0 8px; margin-top: 5px; }
        .stat { font-size: 0.95em; font-weight: bold; padding: 3px 10px; border-radius: 4px; }
        .stat-atk { background: linear-gradient(135deg, #c0392b, #8e2222); }
        .stat-hp { background: linear-gradient(135deg, #27ae60, #1a7a42); }
        .stat-hp.damaged { background: linear-gradient(135deg, #e67e22, #d35400); }
        .card.creature { border: 3px solid #3498db; }
        .card.spell { border: 3px solid #9b59b6; }
        .card.trap-card { border: 3px solid #e74c3c; }
        .card.just-played { opacity: 0.6; }
        .card.just-played::after { content: 'üí§'; position: absolute; top: 4px; right: 4px; font-size: 0.85em; }
        .card.can-attack { box-shadow: 0 0 12px rgba(231,76,60,0.8); }
        .card.field-selected { box-shadow: 0 0 20px rgba(52,152,219,0.9); border-color: #3498db !important; }
        
        /* UNPLAYABLE - TRANSPARENCY */
        .card.unplayable { 
            opacity: 0.35 !important; 
            filter: grayscale(70%) brightness(0.7); 
            cursor: not-allowed !important; 
        }
        
        /* MY HAND - OVERLAPPING CARDS */
        .my-hand { 
            position: absolute; 
            bottom: 8px; 
            left: 120px; 
            display: flex; 
            padding: 12px 20px 12px 10px; 
            background: rgba(20,20,40,0.95); 
            border-radius: 12px 12px 0 0; 
            border: 2px solid #5a4a3a; 
            border-bottom: none; 
            max-width: calc(55% - 130px);
        }
        .my-hand .card {
            margin-left: -55px;
            transition: transform 0.2s, z-index 0s, margin 0.2s;
        }
        .my-hand .card:first-child {
            margin-left: 0;
        }
        .my-hand .card:hover:not(.unplayable) {
            transform: translateY(-40px) scale(1.05);
            z-index: 100;
            margin-left: 0;
            margin-right: 10px;
        }
        .my-hand .card:hover:not(.unplayable) + .card {
            margin-left: 0;
        }
        .my-hand .card.selected {
            transform: translateY(-50px) scale(1.08);
            z-index: 101;
            box-shadow: 0 0 30px rgba(255,215,0,0.8);
            margin-left: 0;
            margin-right: 10px;
        }
        .my-hand .card.selected + .card {
            margin-left: 0;
        }
        
        /* OPPONENT HAND - VERY COMPACT */
        .opp-hand { 
            position: absolute; 
            bottom: 8px; 
            right: 120px; 
            display: flex; 
            padding: 10px 15px; 
            background: rgba(20,20,40,0.95); 
            border-radius: 12px 12px 0 0; 
            border: 2px solid #5a4a3a; 
            border-bottom: none; 
        }
        .opp-card-back { 
            width: 35px; 
            height: 50px; 
            margin-left: -25px;
            border-radius: 4px; 
            background: linear-gradient(135deg, #4a3a2a, #2a2015); 
            border: 2px solid #8b7355; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1em; 
        }
        .opp-card-back:first-child { margin-left: 0; }
        .opp-hand-count {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            color: #aaa;
            white-space: nowrap;
        }
        
        /* LOG */
        .log-btn { position: absolute; top: 60px; right: 15px; width: 38px; height: 38px; border-radius: 50%; background: #5a4a3a; border: 2px solid #8b7355; cursor: pointer; font-size: 1.1em; display: flex; align-items: center; justify-content: center; }
        .log-popup { position: absolute; top: 105px; right: 15px; width: 280px; max-height: 280px; background: rgba(20,20,40,0.98); border: 2px solid #8b7355; border-radius: 10px; padding: 10px; display: none; z-index: 100; }
        .log-popup.active { display: block; }
        .log-popup h3 { color: #ffd700; margin-bottom: 8px; font-size: 0.85em; text-align: center; }
        .log-content { max-height: 220px; overflow-y: auto; font-size: 0.7em; }
        .log-entry { padding: 3px 6px; margin: 2px 0; border-radius: 3px; }
        .log-phase { background: rgba(255,215,0,0.2); color: #ffd700; }
        .log-action { background: rgba(52,152,219,0.2); color: #5dade2; }
        .log-damage { background: rgba(231,76,60,0.2); color: #ec7063; }
        .log-heal { background: rgba(46,204,113,0.2); color: #58d68d; }
        
        /* GAME OVER */
        .game-over { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .game-over.hidden { display: none; }
        .game-over-box { text-align: center; padding: 40px; background: rgba(30,30,50,0.98); border-radius: 15px; border: 4px solid #ffd700; }
        .game-over-title { font-size: 2.5em; color: #ffd700; margin-bottom: 15px; }
        .game-over-result { font-size: 1.3em; margin-bottom: 25px; }
        .game-over-result.victory { color: #2ecc71; }
        .game-over-result.defeat { color: #e74c3c; }
    </style>
</head>
<body>
    <div class="lobby" id="lobby">
        <h1 class="lobby-title">‚öîÔ∏è Bataille des H√©ros</h1>
        <div class="lobby-box" id="lobby-menu">
            <h2 style="margin-bottom:25px;color:#ffd700;">Multijoueur</h2>
            <button class="lobby-btn btn-create" onclick="createRoom()">üéÆ Cr√©er une partie</button>
            <div style="margin:18px 0;color:#666;">‚Äî ou ‚Äî</div>
            <input type="text" class="room-code-input" id="room-code-input" placeholder="CODE" maxlength="6">
            <button class="lobby-btn btn-join" onclick="joinRoom()">üö™ Rejoindre</button>
        </div>
        <div class="lobby-box hidden" id="lobby-waiting">
            <h2 style="color:#ffd700;margin-bottom:15px;">Partie cr√©√©e !</h2>
            <p style="color:#aaa;margin-bottom:8px;">Partagez ce code :</p>
            <div class="room-code-display" id="room-code-display">------</div>
            <p class="waiting-text">‚è≥ En attente d'un adversaire...</p>
        </div>
    </div>

    <div class="game-container" id="game-container">
        <div class="top-bar">
            <div class="player-info-bar">
                <div class="player-name me" id="me-name">ARCHIMAGE</div>
                <div class="energy-orb" id="me-energy">1</div>
            </div>
            <div class="player-info-bar">
                <div class="energy-orb" id="opp-energy">1</div>
                <div class="player-name opp" id="opp-name">GUERRIER</div>
            </div>
        </div>
        
        <button class="end-turn-btn" id="end-turn-btn" onclick="endTurn()">
            <span>FIN DU</span><span>TOUR</span><span class="timer-text" id="timer">90</span>
        </button>
        
        <div class="phase-indicator deploy" id="phase-indicator">üé¥ Phase de D√©ploiement</div>
        
        <div class="hero-zone me">
            <div class="hero-card">
                <div class="ready-dot" id="me-ready"></div>
                <div class="hero-icon" id="me-icon">üßô‚Äç‚ôÇÔ∏è</div>
                <div class="hero-name" id="me-hero">Archimage</div>
                <div class="hero-hp" id="me-hp">20</div>
            </div>
            <div class="deck-pile">
                <div class="deck-card-back">üé¥</div>
                <div class="deck-card-back">üé¥</div>
                <div class="deck-card-back">üé¥</div>
            </div>
            <div class="deck-count"><span id="me-deck">53</span> cartes</div>
        </div>
        
        <div class="hero-zone opp">
            <div class="hero-card">
                <div class="ready-dot" id="opp-ready"></div>
                <div class="hero-icon" id="opp-icon">‚öîÔ∏è</div>
                <div class="hero-name" id="opp-hero">Guerrier</div>
                <div class="hero-hp" id="opp-hp">20</div>
            </div>
            <div class="deck-pile">
                <div class="deck-card-back">üé¥</div>
                <div class="deck-card-back">üé¥</div>
                <div class="deck-card-back">üé¥</div>
            </div>
            <div class="deck-count"><span id="opp-deck">53</span> cartes</div>
        </div>
        
        <div class="battlefield">
            <div class="bf-side me" id="bf-me"></div>
            <div class="trap-col" id="traps-me"></div>
            <div class="trap-col" id="traps-opp"></div>
            <div class="bf-side opp" id="bf-opp"></div>
        </div>
        
        <div class="my-hand" id="my-hand"></div>
        <div class="opp-hand" id="opp-hand"></div>
        
        <div class="log-btn" onclick="toggleLog()">üìú</div>
        <div class="log-popup" id="log-popup">
            <h3>üìú Journal</h3>
            <div class="log-content" id="log-content"></div>
        </div>
    </div>
    
    <div class="game-over hidden" id="game-over">
        <div class="game-over-box">
            <div class="game-over-title">üèÜ Fin de Partie</div>
            <div class="game-over-result" id="result">Victoire !</div>
            <button class="lobby-btn btn-create" onclick="location.reload()">üîÑ Rejouer</button>
        </div>
    </div>

    <script>
        let socket, myNum = 0, state = null;
        let selected = null, dragged = null, targeting = false;
        let currentPhase = 'deploy';
        let hasCreatures = false;
        let isMyTurnReady = false;
        
        function initSocket() {
            socket = io();
            
            socket.on('gameStart', (s) => {
                state = s;
                myNum = s.myPlayer;
                isMyTurnReady = false;
                setupHeroes();
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('game-container').classList.add('active');
                initBattlefield();
                render();
                updatePhaseDisplay();
                log('üéÆ Tour 1 - Partie lanc√©e !', 'phase');
            });
            
            socket.on('gameStateUpdate', (s) => { 
                state = s;
                // Update ready state from server
                isMyTurnReady = state.me.ready;
                render(); 
            });
            
            socket.on('timerUpdate', (t) => { 
                if(state) state.timeLeft = t; 
                document.getElementById('timer').textContent = t; 
            });
            
            socket.on('phaseChange', (p) => { 
                if(state) state.phase = p; 
                if (p === 'resolution') {
                    setPhaseDisplay('resolution');
                } else if (p === 'planning') {
                    checkCreaturesAndSetPhase();
                }
            });
            
            socket.on('playerReady', (n) => { 
                const isMe = n === myNum;
                document.getElementById(isMe ? 'me-ready' : 'opp-ready').classList.add('ready');
                document.getElementById(isMe ? 'me-ready' : 'opp-ready').textContent = '‚úì';
                if (isMe) {
                    isMyTurnReady = true;
                    updateButtonState();
                }
                log(isMe ? 'Vous √™tes pr√™t' : 'Adversaire pr√™t', 'action');
            });
            
            socket.on('newTurn', (d) => {
                console.log('NEW TURN:', d);
                
                // Reset all ready states
                isMyTurnReady = false;
                
                document.getElementById('me-ready').classList.remove('ready');
                document.getElementById('opp-ready').classList.remove('ready');
                document.getElementById('me-ready').textContent = '';
                document.getElementById('opp-ready').textContent = '';
                
                // Reset button
                const btn = document.getElementById('end-turn-btn');
                btn.classList.remove('waiting');
                btn.disabled = false;
                btn.innerHTML = '<span>FIN DU</span><span>TOUR</span><span class="timer-text" id="timer">90</span>';
                
                // Update phase
                currentPhase = 'deploy';
                setPhaseDisplay('deploy');
                
                log(`üéÆ Tour ${d.turn} ‚Äî ‚ö°${d.maxEnergy} √©nergie`, 'phase');
            });
            
            socket.on('resolutionLog', (d) => log(d.msg, d.type));
            
            socket.on('directDamage', (d) => {
                const el = document.getElementById(d.defender === myNum ? 'me-hp' : 'opp-hp');
                el.style.background = 'radial-gradient(circle, #ff0000, #880000)';
                setTimeout(() => el.style.background = '', 300);
            });
            
            socket.on('gameOver', (d) => {
                const won = d.winner === myNum;
                document.getElementById('result').textContent = won ? 'üéâ Victoire !' : 'üò¢ D√©faite';
                document.getElementById('result').className = 'game-over-result ' + (won ? 'victory' : 'defeat');
                document.getElementById('game-over').classList.remove('hidden');
            });
            
            socket.on('playerDisconnected', () => log('‚ö†Ô∏è Adversaire d√©connect√©', 'damage'));
        }
        
        function checkCreaturesAndSetPhase() {
            if (!state) return;
            
            let creatureCount = 0;
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 2; c++) {
                    if (state.me.field[r][c]) creatureCount++;
                }
            }
            
            hasCreatures = creatureCount > 0;
            currentPhase = hasCreatures ? 'redeploy' : 'deploy';
            updatePhaseDisplay();
        }
        
        function setPhaseDisplay(phase) {
            const el = document.getElementById('phase-indicator');
            el.classList.remove('redeploy', 'deploy', 'resolution');
            
            if (phase === 'redeploy') {
                el.textContent = 'üîÑ Phase de Red√©ploiement';
                el.classList.add('redeploy');
            } else if (phase === 'deploy') {
                el.textContent = 'üé¥ Phase de D√©ploiement';
                el.classList.add('deploy');
            } else if (phase === 'resolution') {
                el.textContent = '‚öîÔ∏è R√©solution du Combat';
                el.classList.add('resolution');
            }
        }
        
        function updatePhaseDisplay() {
            if (state && state.phase === 'resolution') {
                setPhaseDisplay('resolution');
            } else {
                setPhaseDisplay(currentPhase);
            }
        }
        
        function switchToDeployPhase() {
            if (currentPhase === 'redeploy') {
                currentPhase = 'deploy';
                updatePhaseDisplay();
                log('‚Üí Phase de D√©ploiement', 'action');
            }
        }
        
        function updateButtonState() {
            const btn = document.getElementById('end-turn-btn');
            if (isMyTurnReady) {
                btn.classList.add('waiting');
                btn.innerHTML = '<span>EN</span><span>ATTENTE</span><span class="timer-text" id="timer">' + (state?.timeLeft || 90) + '</span>';
            }
        }
        
        function setupHeroes() {
            if (myNum === 1) {
                document.getElementById('me-icon').textContent = 'üßô‚Äç‚ôÇÔ∏è';
                document.getElementById('me-hero').textContent = 'Archimage';
                document.getElementById('me-name').textContent = 'ARCHIMAGE (Vous)';
                document.getElementById('opp-icon').textContent = '‚öîÔ∏è';
                document.getElementById('opp-hero').textContent = 'Guerrier';
                document.getElementById('opp-name').textContent = 'GUERRIER';
            } else {
                document.getElementById('me-icon').textContent = '‚öîÔ∏è';
                document.getElementById('me-hero').textContent = 'Guerrier';
                document.getElementById('me-name').textContent = 'GUERRIER (Vous)';
                document.getElementById('opp-icon').textContent = 'üßô‚Äç‚ôÇÔ∏è';
                document.getElementById('opp-hero').textContent = 'Archimage';
                document.getElementById('opp-name').textContent = 'ARCHIMAGE';
            }
        }
        
        function createRoom() {
            socket.emit('createRoom', (r) => {
                if (r.success) {
                    myNum = r.playerNum;
                    document.getElementById('room-code-display').textContent = r.code;
                    document.getElementById('lobby-menu').classList.add('hidden');
                    document.getElementById('lobby-waiting').classList.remove('hidden');
                }
            });
        }
        
        function joinRoom() {
            const code = document.getElementById('room-code-input').value.trim();
            if (!code) return;
            socket.emit('joinRoom', code, (r) => {
                if (r.success) myNum = r.playerNum;
                else alert(r.error);
            });
        }
        
        function initBattlefield() {
            const bfMe = document.getElementById('bf-me');
            const bfOpp = document.getElementById('bf-opp');
            bfMe.innerHTML = ''; bfOpp.innerHTML = '';
            
            // My side: col1 (back) on left, col0 (front) on right
            for (let col = 1; col >= 0; col--)
                for (let row = 0; row < 4; row++)
                    bfMe.appendChild(makeSlot('me', row, col));
            
            // Opponent side: MIRRORED - col0 (front) on left, col1 (back) on right
            // This makes opponent's front face my front
            for (let col = 0; col <= 1; col++)
                for (let row = 0; row < 4; row++)
                    bfOpp.appendChild(makeSlot('opp', row, col));
            
            const tMe = document.getElementById('traps-me');
            const tOpp = document.getElementById('traps-opp');
            tMe.innerHTML = ''; tOpp.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                tMe.appendChild(makeTrap('me', i));
                tOpp.appendChild(makeTrap('opp', i));
            }
        }
        
        function makeSlot(owner, row, col) {
            const el = document.createElement('div');
            el.className = `card-slot ${owner}-slot`;
            el.dataset.owner = owner;
            el.dataset.row = row;
            el.dataset.col = col;
            el.onclick = () => clickSlot(owner, row, col);
            el.ondragover = (e) => { e.preventDefault(); if (canPlay()) el.classList.add('drag-over'); };
            el.ondragleave = () => el.classList.remove('drag-over');
            el.ondrop = (e) => { e.preventDefault(); el.classList.remove('drag-over'); dropOnSlot(owner, row, col); };
            return el;
        }
        
        function makeTrap(owner, idx) {
            const el = document.createElement('div');
            el.className = `trap-slot ${owner}-trap`;
            el.innerHTML = '<span class="trap-inner">‚óá</span>';
            el.dataset.owner = owner;
            el.dataset.idx = idx;
            el.onclick = () => clickTrap(owner, idx);
            el.ondragover = (e) => { e.preventDefault(); if(owner === 'me' && canPlay()) el.classList.add('drag-over'); };
            el.ondragleave = () => el.classList.remove('drag-over');
            el.ondrop = (e) => { e.preventDefault(); el.classList.remove('drag-over'); dropOnTrap(owner, idx); };
            return el;
        }
        
        function canPlay() {
            return state && state.phase === 'planning' && !isMyTurnReady;
        }
        
        function render() {
            if (!state) return;
            const me = state.me, opp = state.opponent;
            
            document.getElementById('me-hp').textContent = me.hp;
            document.getElementById('opp-hp').textContent = opp.hp;
            document.getElementById('me-energy').textContent = `${me.energy}/${me.maxEnergy}`;
            document.getElementById('opp-energy').textContent = `${opp.energy}/${opp.maxEnergy}`;
            document.getElementById('me-deck').textContent = me.deckCount;
            document.getElementById('opp-deck').textContent = opp.deckCount;
            
            renderField('me', me.field);
            renderField('opp', opp.field);
            renderTraps('me', me.traps);
            renderTraps('opp', opp.trapsCount);
            renderHand(me.hand, me.energy);
            renderOppHand(opp.handCount);
            
            // Check creatures for phase
            checkCreaturesAndSetPhase();
            
            // Update ready indicators from state
            if (me.ready) {
                document.getElementById('me-ready').classList.add('ready');
                document.getElementById('me-ready').textContent = '‚úì';
            }
            if (opp.ready) {
                document.getElementById('opp-ready').classList.add('ready');
                document.getElementById('opp-ready').textContent = '‚úì';
            }
            
            updateButtonState();
        }
        
        function renderField(owner, field) {
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 2; c++) {
                    const slot = document.querySelector(`.card-slot[data-owner="${owner}"][data-row="${r}"][data-col="${c}"]`);
                    if (!slot) continue;
                    slot.querySelector('.card')?.remove();
                    slot.classList.remove('has-card', 'moveable');
                    const card = field[r][c];
                    if (card) {
                        slot.classList.add('has-card');
                        const cardEl = makeCard(card, false);
                        if (owner === 'me') {
                            cardEl.onclick = (e) => { e.stopPropagation(); clickFieldCard(r, c, card); };
                        }
                        slot.appendChild(cardEl);
                    }
                }
            }
        }
        
        function renderTraps(owner, data) {
            if (owner === 'me') {
                data.forEach((trap, i) => {
                    const slot = document.querySelector(`.trap-slot[data-owner="me"][data-idx="${i}"]`);
                    if (slot) {
                        slot.classList.toggle('has-trap', !!trap);
                        slot.querySelector('.trap-inner').textContent = trap ? 'üí£' : '‚óá';
                    }
                });
            } else {
                document.querySelectorAll('.trap-slot[data-owner="opp"]').forEach((slot, i) => {
                    slot.classList.toggle('has-trap', i < data);
                    slot.querySelector('.trap-inner').textContent = i < data ? '‚ùì' : '‚óá';
                });
            }
        }
        
        function renderHand(hand, energy) {
            const panel = document.getElementById('my-hand');
            panel.innerHTML = '';
            hand.forEach((card, i) => {
                const el = makeCard(card, true);
                el.dataset.idx = i;
                
                // Mark unplayable cards
                if (card.cost > energy) {
                    el.classList.add('unplayable');
                    el.draggable = false;
                } else {
                    el.draggable = true;
                }
                
                el.onclick = (e) => { e.stopPropagation(); selectCard(i); };
                el.ondragstart = (e) => {
                    if (card.cost > energy || !canPlay()) { e.preventDefault(); return; }
                    dragged = { ...card, idx: i };
                    el.classList.add('dragging');
                    if (card.type === 'spell') {
                        targeting = true;
                        document.querySelectorAll('.card-slot').forEach(s => s.classList.add('targetable'));
                    }
                };
                el.ondragend = () => {
                    el.classList.remove('dragging');
                    dragged = null;
                    targeting = false;
                    document.querySelectorAll('.card-slot, .trap-slot').forEach(s => s.classList.remove('targetable', 'drag-over'));
                };
                
                panel.appendChild(el);
            });
        }
        
        function renderOppHand(count) {
            const panel = document.getElementById('opp-hand');
            panel.innerHTML = '';
            for (let i = 0; i < Math.min(count, 15); i++) {
                const el = document.createElement('div');
                el.className = 'opp-card-back';
                el.textContent = 'üé¥';
                panel.appendChild(el);
            }
            const countEl = document.createElement('div');
            countEl.className = 'opp-hand-count';
            countEl.textContent = count + ' cartes';
            panel.appendChild(countEl);
        }
        
        function makeCard(card, inHand) {
            const el = document.createElement('div');
            el.className = `card ${card.type === 'trap' ? 'trap-card' : card.type}`;
            
            if (!inHand && card.type === 'creature') {
                if (card.turnsOnField === 0 && !card.abilities?.includes('haste')) el.classList.add('just-played');
                if (card.canAttack) el.classList.add('can-attack');
            }
            
            const icons = { fly: 'ü¶Ö', shooter: 'üéØ', haste: '‚ö°' };
            const abilities = (card.abilities || []).map(a => icons[a] || '').join(' ');
            const hp = card.currentHp ?? card.hp;
            const hpClass = card.type === 'creature' && hp < card.hp ? 'damaged' : '';
            
            el.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                <div class="card-art">${card.icon || '‚ùì'}</div>
                <div class="card-body">
                    <div class="card-name">${card.name}</div>
                    <div class="card-abilities">${abilities || (card.type === 'spell' ? (card.offensive ? '‚öîÔ∏è' : 'üõ°Ô∏è') : '')}</div>
                    <div class="card-stats">
                        ${card.atk !== undefined ? `<span class="stat stat-atk">${card.atk}</span>` : ''}
                        ${card.damage ? `<span class="stat stat-atk">${card.damage}</span>` : ''}
                        ${card.heal ? `<span class="stat stat-hp">${card.heal}</span>` : ''}
                        ${card.type === 'creature' ? `<span class="stat stat-hp ${hpClass}">${hp}</span>` : ''}
                    </div>
                </div>`;
            return el;
        }
        
        function selectCard(i) {
            if (!canPlay()) return;
            
            const card = state.me.hand[i];
            if (card.cost > state.me.energy) return;
            
            clearSel();
            selected = { ...card, idx: i, fromHand: true };
            document.querySelectorAll('.my-hand .card')[i]?.classList.add('selected');
            
            if (card.type === 'spell') {
                targeting = true;
                document.querySelectorAll('.card-slot').forEach(s => s.classList.add('targetable'));
            }
        }
        
        function clickFieldCard(row, col, card) {
            if (!canPlay()) return;
            if (currentPhase !== 'redeploy') return;
            if (card.movedThisTurn) return;
            
            clearSel();
            selected = { ...card, fromField: true, row, col };
            
            const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${row}"][data-col="${col}"]`);
            const cardEl = slot?.querySelector('.card');
            if (cardEl) cardEl.classList.add('field-selected');
            
            highlightMoveTargets(row, col, card);
        }
        
        function highlightMoveTargets(fromRow, fromCol, card) {
            const fly = card.abilities?.includes('fly');
            const shooter = card.abilities?.includes('shooter');
            
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 2; c++) {
                    if (r === fromRow && c === fromCol) continue;
                    if (state.me.field[r][c]) continue;
                    
                    const rd = Math.abs(r - fromRow);
                    const cd = Math.abs(c - fromCol);
                    
                    // Only adjacent movement
                    if (!((rd === 1 && cd === 0) || (rd === 0 && cd === 1 && fly))) continue;
                    
                    // Check position restrictions
                    const toBack = c === 1;
                    if (toBack && !fly && !shooter) continue;
                    if (c === 0 && shooter && !fly) continue;
                    
                    const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${r}"][data-col="${c}"]`);
                    if (slot) slot.classList.add('moveable');
                }
            }
        }
        
        function clickSlot(owner, row, col) {
            if (!canPlay()) return;
            
            // Spell targeting
            if (targeting && selected && selected.fromHand) {
                const targetPlayer = owner === 'me' ? myNum : (myNum === 1 ? 2 : 1);
                socket.emit('castSpell', { handIndex: selected.idx, targetPlayer, row, col });
                switchToDeployPhase();
                clearSel();
                return;
            }
            
            if (owner !== 'me') return;
            
            // Place creature from hand
            if (selected && selected.fromHand && selected.type === 'creature') {
                socket.emit('placeCard', { handIndex: selected.idx, row, col });
                switchToDeployPhase();
                clearSel();
                return;
            }
            
            // Move creature on field
            if (selected && selected.fromField) {
                const slot = document.querySelector(`.card-slot[data-owner="me"][data-row="${row}"][data-col="${col}"]`);
                if (slot && slot.classList.contains('moveable')) {
                    socket.emit('moveCard', { fromRow: selected.row, fromCol: selected.col, toRow: row, toCol: col });
                    clearSel();
                    return;
                }
            }
            
            // Click on a creature to select it for movement
            const card = state.me.field[row][col];
            if (card && currentPhase === 'redeploy' && !card.movedThisTurn) {
                clickFieldCard(row, col, card);
            }
        }
        
        function clickTrap(owner, idx) {
            if (!canPlay() || owner !== 'me') return;
            if (selected && selected.fromHand && selected.type === 'trap') {
                socket.emit('placeTrap', { handIndex: selected.idx, trapIndex: idx });
                switchToDeployPhase();
                clearSel();
            }
        }
        
        function dropOnSlot(owner, row, col) {
            if (!dragged || !canPlay()) return;
            
            if (dragged.type === 'spell') {
                const targetPlayer = owner === 'me' ? myNum : (myNum === 1 ? 2 : 1);
                socket.emit('castSpell', { handIndex: dragged.idx, targetPlayer, row, col });
                switchToDeployPhase();
            } else if (dragged.type === 'creature' && owner === 'me') {
                socket.emit('placeCard', { handIndex: dragged.idx, row, col });
                switchToDeployPhase();
            }
            clearSel();
        }
        
        function dropOnTrap(owner, idx) {
            if (!dragged || !canPlay() || owner !== 'me') return;
            if (dragged.type === 'trap') {
                socket.emit('placeTrap', { handIndex: dragged.idx, trapIndex: idx });
                switchToDeployPhase();
            }
            clearSel();
        }
        
        function endTurn() {
            if (!canPlay()) return;
            socket.emit('ready');
        }
        
        function clearSel() {
            selected = null;
            dragged = null;
            targeting = false;
            document.querySelectorAll('.card').forEach(e => e.classList.remove('selected', 'field-selected'));
            document.querySelectorAll('.card-slot').forEach(e => e.classList.remove('targetable', 'drag-over', 'moveable'));
            document.querySelectorAll('.trap-slot').forEach(e => e.classList.remove('drag-over'));
        }
        
        function toggleLog() {
            document.getElementById('log-popup').classList.toggle('active');
        }
        
        function log(msg, type = 'action') {
            const el = document.createElement('div');
            el.className = `log-entry log-${type}`;
            el.textContent = msg;
            const c = document.getElementById('log-content');
            c.appendChild(el);
            c.scrollTop = c.scrollHeight;
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initSocket();
            document.getElementById('room-code-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.card') && !e.target.closest('.card-slot') && !e.target.closest('.trap-slot')) {
                    clearSel();
                }
            });
        });
    </script>
</body>
</html>
